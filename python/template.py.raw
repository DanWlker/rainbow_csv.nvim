#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import unicode_literals
from __future__ import print_function
import sys
import os
import random #for random sort
import datetime #for date manipulations
import re #for regexes
import codecs
from collections import OrderedDict

sys.path.insert(0, '__RBQLMP__rbql_home_dir')
import rbql_utils

__RBQLMP__import_expression


PY3 = sys.version_info[0] == 3


def iteritems6(x):
    if PY3:
        return x.items()
    return x.iteritems()


def str6(obj):
    #we have to use this function because str() for python2.7 tries to ascii-encode unicode strings
    if PY3 and isinstance(obj, str):
        return obj
    if not PY3 and isinstance(obj, basestring):
        return obj
    return str(obj)


DLM = '__RBQLMP__dlm'


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


class BadFieldError(Exception):
    def __init__(self, bad_idx):
        self.bad_idx = bad_idx

class RbqlRuntimeError(Exception):
    pass


def safe_get(record, idx):
    try:
        return record[idx - 1]
    except IndexError as e:
        raise BadFieldError(idx - 1)


def safe_set(record, idx, value):
    try:
        record[idx - 1] = value
    except IndexError as e:
        raise BadFieldError(idx - 1)


module_was_used_failsafe = False

#For warnings:
join_fields_info = dict()
input_fields_info = dict()
output_fields_info = dict()
null_value_in_output = False
defective_csv_line_in_input = 0
defective_csv_line_in_join = 0


def smart_split(line):
    if DLM == ',':
        return rbql_utils.split_escaped_csv_str(line)
    else:
        return (line.split(DLM), 0)


def register_num_fields(line_num, line):
    global output_fields_info
    num_fields = line.count('\t')
    if num_fields not in output_fields_info:
        output_fields_info[num_fields] = line_num


class SimpleWriter:
    def __init__(self, dst):
        self.dst = dst
        self.NW = 0

    def write(self, record):
        if __RBQLMP__top_count is not None and self.NW >= __RBQLMP__top_count:
            return False
        self.dst.write(record)
        self.dst.write('\n')
        self.NW += 1
        register_num_fields(self.NW, record)
        return True

    def finish(self):
        pass


def add_to_set(dst_set, value):
    # https://stackoverflow.com/a/27427447/2898283
    # TODO run tests to compare performance
    len_before = len(dst_set)
    dst_set.add(value)
    return len_before != len(dst_set)


class UniqWriter:
    def __init__(self, dst):
        self.dst = dst
        self.seen = set()
        self.NW = 0

    def write(self, record):
        if __RBQLMP__top_count is not None and self.NW >= __RBQLMP__top_count:
            return False
        if not add_to_set(self.seen, record):
            return True
        self.dst.write(record)
        self.dst.write('\n')
        self.NW += 1
        register_num_fields(self.NW, record)
        return True

    def finish(self):
        pass


class UniqCountWriter:
    # we can't optimize this for ordered result set:
    # they might be ordered not by output records, but by some other expression
    def __init__(self, dst):
        self.dst = dst
        self.records = OrderedDict()

    def write(self, record):
        if record in self.records:
            self.records[record] += 1
        else:
            self.records[record] = 1
        return True

    def finish(self):
        NW = 0
        for record, count in iteritems6(self.records):
            if __RBQLMP__top_count is not None and NW >= __RBQLMP__top_count:
                break
            self.dst.write('{}\t{}\n'.format(count, record))
            NW += 1
            register_num_fields(NW, record)


def read_join_table(join_table_path):
    global join_fields_info
    global defective_csv_line_in_join
    fields_max_len = 0
    if not os.path.isfile(join_table_path):
        raise RbqlRuntimeError('Table B: ' + join_table_path + ' is not accessible')
    result = dict()
    with codecs.open(join_table_path, encoding='__RBQLMP__join_encoding') as src_text:
        for il, line in enumerate(rbql_utils.rows(src_text), 1):
            line = line.rstrip('\r\n')
            bfields, warning = smart_split(line)
            if warning and not defective_csv_line_in_join:
                defective_csv_line_in_join = il
            num_fields = len(bfields)
            fields_max_len = max(fields_max_len, num_fields)
            if num_fields not in join_fields_info:
                join_fields_info[num_fields] = il
            try:
                key = __RBQLMP__rhs_join_var
            except BadFieldError as e:
                bad_idx = e.bad_idx
                raise RbqlRuntimeError('No "b' + str(bad_idx + 1) + '" column at line: ' + str(il) + ' in "B" table')
            if key in result:
                raise RbqlRuntimeError('Join column must be unique in right-hand-side "B" table. Found duplicate key: "' + key + '"')
            result[key] = bfields
    return (result, fields_max_len)


def none_joiner(path):
    return None


class InnerJoiner:
    def __init__(self, join_table_path):
        self.join_data, self.fields_max_len = read_join_table(join_table_path)
    def get(self, lhs_key):
        return self.join_data.get(lhs_key, None)


class LeftJoiner:
    def __init__(self, join_table_path):
        self.join_data, self.fields_max_len = read_join_table(join_table_path)
    def get(self, lhs_key):
        return self.join_data.get(lhs_key, [None] * self.fields_max_len)


class StrictLeftJoiner:
    def __init__(self, join_table_path):
        self.join_data, self.fields_max_len = read_join_table(join_table_path)
    def get(self, lhs_key):
        result = self.join_data.get(lhs_key, None)
        if result is None:
            raise RbqlRuntimeError('In "strict left join" mode all A table keys must be present in table B. Key "' + lhs_key + '" was not found')
        return result


def replace_none_values(fields):
    global null_value_in_output
    i = 0
    while i < len(fields):
        if fields[i] is None:
            fields[i] = ''
            null_value_in_output = True
        i += 1


def create_warnings_report():
    warnings = dict()
    if defective_csv_line_in_join != 0:
        warnings['defective_csv_line_in_join'] = defective_csv_line_in_join
    if defective_csv_line_in_input != 0:
        warnings['defective_csv_line_in_input'] = defective_csv_line_in_input
    if null_value_in_output:
        warnings['null_value_in_output'] = True
    if len(output_fields_info) > 1:
        warnings['output_fields_info'] = output_fields_info
    if len(input_fields_info) > 1:
        warnings['input_fields_info'] = input_fields_info
    if len(join_fields_info) > 1:
        warnings['join_fields_info'] = join_fields_info
    if not len(warnings):
        return None
    return warnings


def main():
    warnings = rb_transform(sys.stdin, sys.stdout)
    if warnings is not None:
        for k, v in warnings.items():
            eprint(k, v)


def rb_transform(source, destination):
    global module_was_used_failsafe
    assert not module_was_used_failsafe
    module_was_used_failsafe = True
    global input_fields_info
    global defective_csv_line_in_input
    unsorted_entries = list()
    writer = __RBQLMP__writer_type(destination)
    joiner = __RBQLMP__joiner_type('__RBQLMP__rhs_table_path')
    for NR, line in enumerate(rbql_utils.rows(source), 1):
        line = line.rstrip('\r\n')
        afields, warning = smart_split(line)
        if warning and not defective_csv_line_in_input:
            defective_csv_line_in_input = NR
        star_fields = afields
        NF = len(afields)
        if NF not in input_fields_info:
            input_fields_info[NF] = NR
        bfields = None
        join_flag = True
        try:
            if joiner is not None:
                bfields = joiner.get(__RBQLMP__lhs_join_var)
                if bfields is None:
                    join_flag = False
                else:
                    star_fields = afields + bfields
            if __RBQLMP__is_select_query:
                if not (join_flag and (__RBQLMP__where_expression)):
                    continue
                out_fields = __RBQLMP__select_expression
            else:
                if join_flag and (__RBQLMP__where_expression):
                    __RBQLMP__update_statements
                out_fields = afields
            replace_none_values(out_fields)
            if __RBQLMP__sort_flag:
                sort_key_value = (__RBQLMP__sort_key_expression)
                unsorted_entries.append((sort_key_value, '\t'.join([str6(f) for f in out_fields])))
            else:
                if not writer.write('\t'.join([str6(f) for f in out_fields])):
                    break
        except BadFieldError as e:
            bad_idx = e.bad_idx
            raise RbqlRuntimeError('No "a' + str(bad_idx + 1) + '" column at line: ' + str(NR))
        except Exception as e:
            raise RbqlRuntimeError('Error at line: ' + str(NR) + ', Details: ' + str(e))
    if len(unsorted_entries):
        sorted_entries = sorted(unsorted_entries, key=lambda x: x[0])
        if __RBQLMP__reverse_flag:
            sorted_entries.reverse()
        for e in sorted_entries:
            if not writer.write(e[1]):
                break
    writer.finish()
    return create_warnings_report()


if __name__ == '__main__':
    main()



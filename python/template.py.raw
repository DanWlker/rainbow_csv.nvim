#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import unicode_literals
import sys
import os
import random #for random sort
import datetime #for date manipulations
import re #for regexes
import codecs
sys.path.insert(0, '__RBQLMP__rbql_home_dir')
import rbql_utils

__RBQLMP__import_expression


PY3 = sys.version_info[0] == 3

def str6(obj):
    if PY3 and isinstance(obj, str):
        return obj
    if not PY3 and isinstance(obj, basestring):
        return obj
    return str(obj)


DLM = '__RBQLMP__dlm'


def smart_split(line):
    if DLM == ',':
        return rbql_utils.split_escaped_csv_str(line)
    else:
        return line.split(DLM)


class BadFieldError(Exception):
    def __init__(self, bad_idx):
        self.bad_idx = bad_idx

class RbqlRuntimeError(Exception):
    pass


def safe_get(record, idx):
    try:
        return record[idx]
    except IndexError as e:
        raise BadFieldError(idx)


class Flike:
    def __init__(self):
        self._cache = dict()

    def _like_to_regex(self, pattern):
        p = 0
        i = 0
        converted = ''
        while i < len(pattern):
            if pattern[i] in ['_', '%']:
                converted += re.escape(pattern[p:i])
                p = i + 1
                if pattern[i] == '_':
                    converted += '.'
                else:
                    converted += '.*'
            i += 1
        converted += re.escape(pattern[p:i])
        return '^' + converted + '$'

    def __call__(self, text, pattern):
        if pattern not in self._cache:
            rgx = self._like_to_regex(pattern)
            self._cache[pattern] = re.compile(rgx)
        return self._cache[pattern].match(text) is not None

flike = Flike()


class SimpleWriter:
    def __init__(self, dst):
        self.dst = dst
        self.NW = 0

    def write(self, record):
        self.dst.write(record)
        self.dst.write('\n')
        self.NW += 1


class UniqWriter:
    def __init__(self, dst):
        self.dst = dst
        self.seen = set()

    def write(self, record):
        if record in self.seen:
            return
        self.seen.add(record)
        self.dst.write(record)
        self.dst.write('\n')


def read_join_table(join_table_path):
    fields_max_len = 0
    if not os.path.isfile(join_table_path):
        raise RbqlRuntimeError('Table B: ' + join_table_path + ' is not accessible')
    result = dict()
    with codecs.open(join_table_path, encoding='__RBQLMP__join_encoding') as src_text:
        for il, line in enumerate(rbql_utils.rows(src_text), 1):
            line = line.rstrip('\r\n')
            bfields = smart_split(line)
            fields_max_len = max(fields_max_len, len(bfields))
            try:
                key = __RBQLMP__rhs_join_var
            except BadFieldError as e:
                bad_idx = e.bad_idx
                raise RbqlRuntimeError('No "b' + str(bad_idx + 1) + '" column at line: ' + str(il) + ' in "B" table')
            if key in result:
                raise RbqlRuntimeError('Join column must be unique in right-hand-side "B" table. Found duplicate key: "' + key + '"')
            result[key] = bfields
    return (result, fields_max_len)


def none_joiner(path):
    return None


class InnerJoiner:
    def __init__(self, join_table_path):
        self.join_data, self.fields_max_len = read_join_table(join_table_path)
    def get(self, lhs_key):
        return self.join_data.get(lhs_key, None)


class LeftJoiner:
    def __init__(self, join_table_path):
        self.join_data, self.fields_max_len = read_join_table(join_table_path)
    def get(self, lhs_key):
        return self.join_data.get(lhs_key, [None] * self.fields_max_len)


class StrictLeftJoiner:
    def __init__(self, join_table_path):
        self.join_data, self.fields_max_len = read_join_table(join_table_path)
    def get(self, lhs_key):
        result = self.join_data.get(lhs_key, None)
        if result is None:
            raise RbqlRuntimeError('In "strict left join" mode all A table keys must be present in table B. Key "' + lhs_key + '" was not found')
        return result


def main():
    rb_transform(sys.stdin, sys.stdout)


def rb_transform(source, destination):
    unsorted_entries = list()
    writer = __RBQLMP__writer_type(destination)
    joiner = __RBQLMP__joiner_type('__RBQLMP__rhs_table_path')
    for NR, line in enumerate(rbql_utils.rows(source), 1):
        line = line.rstrip('\r\n')
        fields = smart_split(line)
        star_line = '\t'.join(fields)
        NF = len(fields)
        bfields = None
        try:
            if joiner is not None:
                bfields = joiner.get(__RBQLMP__lhs_join_var)
                if bfields is None:
                    continue
                star_line = '\t'.join([line] + [str6(f) for f in bfields])
            if not (__RBQLMP__where_expression):
                continue
            out_fields = [__RBQLMP__select_expression]
            if __RBQLMP__sort_flag:
                sort_key_value = (__RBQLMP__sort_key_expression)
                unsorted_entries.append((sort_key_value, '\t'.join([str6(f) for f in out_fields])))
            else:
                if __RBQLMP__top_count != -1 and writer.NW >= __RBQLMP__top_count:
                    break
                writer.write('\t'.join([str6(f) for f in out_fields]))
        except BadFieldError as e:
            bad_idx = e.bad_idx
            raise RbqlRuntimeError('No "a' + str(bad_idx + 1) + '" column at line: ' + str(NR))
        except Exception as e:
            raise RbqlRuntimeError('Error at line: ' + str(NR) + ', Details: ' + str(e))
    if len(unsorted_entries):
        sorted_entries = sorted(unsorted_entries, key=lambda x: x[0])
        if __RBQLMP__reverse_flag:
            sorted_entries.reverse()
        for e in sorted_entries:
            if __RBQLMP__top_count != -1 and writer.NW >= __RBQLMP__top_count:
                break
            writer.write(e[1])


if __name__ == '__main__':
    main()



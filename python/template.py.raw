#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import unicode_literals
from __future__ import print_function
import sys
import os
import random #for random sort
import datetime #for date manipulations
import re #for regexes
import codecs
sys.path.insert(0, '__RBQLMP__rbql_home_dir')
import rbql_utils

__RBQLMP__import_expression


PY3 = sys.version_info[0] == 3

def str6(obj):
    #FIXME get rid of this function
    if PY3 and isinstance(obj, str):
        return obj
    if not PY3 and isinstance(obj, basestring):
        return obj
    return str(obj)


DLM = '__RBQLMP__dlm'


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


def smart_split(line):
    if DLM == ',':
        return rbql_utils.split_escaped_csv_str(line)
    else:
        return line.split(DLM)


class BadFieldError(Exception):
    def __init__(self, bad_idx):
        self.bad_idx = bad_idx

class RbqlRuntimeError(Exception):
    pass


def safe_get(record, idx):
    try:
        return record[idx]
    except IndexError as e:
        raise BadFieldError(idx)


module_was_used_failsafe = False

#For warnings:
join_fields_info = dict()
input_fields_info = dict()
output_fields_info = dict()
null_value_in_output = False
join_table_has_double_quote = False
join_table_has_escaped_quote = False
input_table_has_double_quote = False
input_table_has_escaped_quote = False


def register_num_fields(line_num, line):
    global output_fields_info
    num_fields = line.count('\t')
    if num_fields not in output_fields_info:
        output_fields_info[num_fields] = line_num


class SimpleWriter:
    def __init__(self, dst):
        self.dst = dst
        self.NW = 0

    def write(self, record):
        self.dst.write(record)
        self.dst.write('\n')
        self.NW += 1
        register_num_fields(self.NW, record)


class UniqWriter:
    def __init__(self, dst):
        self.dst = dst
        self.seen = set()
        self.NW = 0

    def write(self, record):
        if record in self.seen:
            return
        self.seen.add(record)
        self.dst.write(record)
        self.dst.write('\n')
        self.NW += 1
        register_num_fields(self.NW, record)


def read_join_table(join_table_path):
    global join_table_has_double_quote
    global join_table_has_escaped_quote
    global join_fields_info
    fields_max_len = 0
    if not os.path.isfile(join_table_path):
        raise RbqlRuntimeError('Table B: ' + join_table_path + ' is not accessible')
    result = dict()
    with codecs.open(join_table_path, encoding='__RBQLMP__join_encoding') as src_text:
        for il, line in enumerate(rbql_utils.rows(src_text), 1):
            line = line.rstrip('\r\n')
            if DLM == ',':
                join_table_has_double_quote = join_table_has_double_quote or line.find('""') != -1
                join_table_has_escaped_quote = join_table_has_escaped_quote or line.find('\\"') != -1
            bfields = smart_split(line)
            num_fields = len(bfields)
            fields_max_len = max(fields_max_len, num_fields)
            if num_fields not in join_fields_info:
                join_fields_info[num_fields] = il
            try:
                key = __RBQLMP__rhs_join_var
            except BadFieldError as e:
                bad_idx = e.bad_idx
                raise RbqlRuntimeError('No "b' + str(bad_idx + 1) + '" column at line: ' + str(il) + ' in "B" table')
            if key in result:
                raise RbqlRuntimeError('Join column must be unique in right-hand-side "B" table. Found duplicate key: "' + key + '"')
            result[key] = bfields
    return (result, fields_max_len)


def none_joiner(path):
    return None


class InnerJoiner:
    def __init__(self, join_table_path):
        self.join_data, self.fields_max_len = read_join_table(join_table_path)
    def get(self, lhs_key):
        return self.join_data.get(lhs_key, None)


class LeftJoiner:
    def __init__(self, join_table_path):
        self.join_data, self.fields_max_len = read_join_table(join_table_path)
    def get(self, lhs_key):
        return self.join_data.get(lhs_key, [None] * self.fields_max_len)


class StrictLeftJoiner:
    def __init__(self, join_table_path):
        self.join_data, self.fields_max_len = read_join_table(join_table_path)
    def get(self, lhs_key):
        result = self.join_data.get(lhs_key, None)
        if result is None:
            raise RbqlRuntimeError('In "strict left join" mode all A table keys must be present in table B. Key "' + lhs_key + '" was not found')
        return result


def replace_none_values(fields):
    global null_value_in_output
    i = 0
    while i < len(fields):
        if fields[i] is None:
            fields[i] = ''
            null_value_in_output = True
        i += 1


def create_warnings_report():
    warnings = dict()
    if input_table_has_double_quote:
        warnings['input_table_has_double_quote'] = True
    if input_table_has_escaped_quote:
        warnings['input_table_has_escaped_quote'] = True
    if join_table_has_double_quote:
        warnings['join_table_has_double_quote'] = True
    if join_table_has_escaped_quote:
        warnings['join_table_has_escaped_quote'] = True
    if null_value_in_output:
        warnings['null_value_in_output'] = True
    if len(output_fields_info) > 1:
        warnings['output_fields_info'] = output_fields_info
    if len(input_fields_info) > 1:
        warnings['input_fields_info'] = input_fields_info
    if len(join_fields_info) > 1:
        warnings['join_fields_info'] = join_fields_info
    if not len(warnings):
        return None
    return warnings


def main():
    warnings = rb_transform(sys.stdin, sys.stdout)
    if warnings is not None:
        for k, v in warnings.items():
            eprint(k, v)


def rb_transform(source, destination):
    #FIXME must return dictionary with unformatted warnings or None.
    global module_was_used_failsafe
    assert not module_was_used_failsafe
    module_was_used_failsafe = True
    global input_table_has_double_quote
    global input_table_has_escaped_quote
    global input_fields_info
    unsorted_entries = list()
    writer = __RBQLMP__writer_type(destination)
    joiner = __RBQLMP__joiner_type('__RBQLMP__rhs_table_path')
    for NR, line in enumerate(rbql_utils.rows(source), 1):
        line = line.rstrip('\r\n')
        if DLM == ',':
            input_table_has_double_quote = input_table_has_double_quote or line.find('""') != -1
            input_table_has_escaped_quote = input_table_has_escaped_quote or line.find('\\"') != -1
        fields = smart_split(line)
        star_line = '\t'.join(fields)
        NF = len(fields)
        if NF not in input_fields_info:
            input_fields_info[NF] = NR
        bfields = None
        try:
            if joiner is not None:
                bfields = joiner.get(__RBQLMP__lhs_join_var)
                if bfields is None:
                    continue
                star_line = '\t'.join([line] + [str6(f) for f in bfields])
            if not (__RBQLMP__where_expression):
                continue
            out_fields = [__RBQLMP__select_expression]
            replace_none_values(out_fields)
            if __RBQLMP__sort_flag:
                sort_key_value = (__RBQLMP__sort_key_expression)
                unsorted_entries.append((sort_key_value, '\t'.join([str6(f) for f in out_fields])))
            else:
                if __RBQLMP__top_count != -1 and writer.NW >= __RBQLMP__top_count:
                    break
                writer.write('\t'.join([str6(f) for f in out_fields]))
        except BadFieldError as e:
            bad_idx = e.bad_idx
            raise RbqlRuntimeError('No "a' + str(bad_idx + 1) + '" column at line: ' + str(NR))
        except Exception as e:
            raise RbqlRuntimeError('Error at line: ' + str(NR) + ', Details: ' + str(e))
    if len(unsorted_entries):
        sorted_entries = sorted(unsorted_entries, key=lambda x: x[0])
        if __RBQLMP__reverse_flag:
            sorted_entries.reverse()
        for e in sorted_entries:
            if __RBQLMP__top_count != -1 and writer.NW >= __RBQLMP__top_count:
                break
            writer.write(e[1])
    return create_warnings_report()


if __name__ == '__main__':
    main()


